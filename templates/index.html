<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>My Coin Wallet</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; max-width: 900px; margin: auto; }
    h2 { margin-top: 24px; }
    pre { background: #f5f5f5; padding: 8px; overflow-x:auto; }
    .row { display:flex; gap:8px; margin-bottom:8px; }
    input[type=text], input[type=number] { width: 100%; padding:6px; }
    button { padding:8px 12px; }
    .msg { margin-top:8px; color: #006; }
    .block { border:1px solid #ddd; padding:8px; margin-bottom:8px; }
  </style>
</head>
<body>
  <h1>My Coin Wallet</h1>

  <section id="key_mgmt">
    <h2>鍵管理</h2>
    <div class="row">
      <button id="gen_keys">鍵ペア生成</button>
      <button id="reset_keys">ローカル鍵リセット</button>
      <button id="export_pub">公開鍵を表示</button>
    </div>
    <div>
      <div><strong>公開鍵 (SPKI base64)</strong></div>
      <pre id="pub_display">（未生成）</pre>
      <div><strong>秘密鍵（JWK - 保管用）</strong></div>
      <pre id="priv_display">（未生成）</pre>
    </div>
  </section>

  <section id="send">
    <h2>送金</h2>
    <div>
      <label>相手の公開鍵 (SPKI base64)</label>
      <input id="tx_to" type="text" placeholder="相手の公開鍵を貼り付け">
    </div>
    <div>
      <label>金額</label>
      <input id="tx_amount" type="number" step="0.00000001" value="1">
    </div>
    <div class="row">
      <button id="create_tx">送金（署名してサーバーへ送信）</button>
      <button id="local_sign">ローカルで署名のみ（pending保存）</button>
    </div>
    <div id="send_msg" class="msg"></div>
  </section>

  <section id="balance">
    <h2>残高確認</h2>
    <div>
      <label>公開鍵</label>
      <input id="balance_pub" type="text" placeholder="確認したい公開鍵">
    </div>
    <div class="row">
      <button id="check_balance">残高取得</button>
      <button id="sync_chain">サーバーとチェーン比較・同期</button>
    </div>
    <div id="balance_display" class="msg"></div>
  </section>

  <section id="chain">
    <h2>ブロックチェーン</h2>
    <div class="row">
      <button id="show_chain">現在のチェーンを取得・表示</button>
      <button id="adopt_chain">サーバーと比較して長い方を採用</button>
      <button id="clear_local_chain">ローカルのトランザクション・チェーンを削除</button>
    </div>
    <div id="chain_display"></div>
  </section>

  <section id="mining">
    <h2>マイニング</h2>
    <div class="row">
      <button id="start_mine">マイニング開始</button>
    </div>
    <div id="mine_status" class="msg"></div>
  </section>

  <section id="events">
    <h2>イベントログ</h2>
    <div id="event_log"></div>
  </section>

<script>
/*
  クライアント側ロジック：
  - Web Crypto API で ECDSA P-256 鍵ペアを生成、秘密鍵は JWK で localStorage に保存。
  - 公開鍵は SPKI DER -> base64 にしてサーバーに渡す（および本人識別として使用）。
  - 署名は message = JSON.stringify({from,to,amount}) を UTF-8 バイト列にして ECDSA-SHA256 で行い、signature を base64 にして tx に含める。
  - localStorage keys:
    - keys: {pub_spki: "...", priv_jwk: {...}}
    - pending_txs: [...]
    - chain: [...]
*/

const API_ROOT = '';

function toBase64(arrayBuffer) {
  const u8 = new Uint8Array(arrayBuffer || []);
  let binary = '';
  for (let i = 0; i < u8.byteLength; i++) binary += String.fromCharCode(u8[i]);
  return btoa(binary);
}
function fromBase64ToArrayBuffer(b64) {
  const binary = atob(b64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}
function utf8encode(s){ return new TextEncoder().encode(s); }
function save_local(key, obj) { localStorage.setItem(key, JSON.stringify(obj)); }
function load_local(key) { const v = localStorage.getItem(key); return v ? JSON.parse(v) : null; }

// Key management
async function generate_keys() {
  const kp = await crypto.subtle.generateKey(
    { name: 'ECDSA', namedCurve: 'P-256' },
    true,
    ['sign','verify']
  );
  // export SPKI
  const spki = await crypto.subtle.exportKey('spki', kp.publicKey);
  const spki_b64 = toBase64(spki);
  const jwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
  save_local('keys', { pub_spki: spki_b64, priv_jwk: jwk });
  document.getElementById('pub_display').textContent = spki_b64;
  document.getElementById('priv_display').textContent = JSON.stringify(jwk, null, 2);
  logEvent('鍵ペア生成完了');
}

async function reset_keys() {
  localStorage.removeItem('keys');
  document.getElementById('pub_display').textContent = '（未生成）';
  document.getElementById('priv_display').textContent = '（未生成）';
  logEvent('ローカル鍵リセット');
}

// helper to import private key from JWK
async function import_private_from_jwk(jwk) {
  return await crypto.subtle.importKey('jwk', jwk, { name:'ECDSA', namedCurve:'P-256' }, true, ['sign']);
}
async function import_pub_from_spki_b64(spki_b64) {
  const ab = fromBase64ToArrayBuffer(spki_b64);
  return await crypto.subtle.importKey('spki', ab, { name:'ECDSA', namedCurve:'P-256' }, true, ['verify']);
}

// Signing and sending tx
async function create_and_send_tx(sendTo, amount, submitToServer=true) {
  const keys = load_local('keys');
  if (!keys) { setSendMsg('鍵が存在しません'); return; }
  const from = keys.pub_spki;
  const priv = keys.priv_jwk;
  const privKey = await import_private_from_jwk(priv);
  const message = JSON.stringify({ from, to: sendTo, amount: Number(amount) });
  const sig = await crypto.subtle.sign({ name:'ECDSA', hash:{name:'SHA-256'} }, privKey, utf8encode(message));
  const sig_b64 = toBase64(sig);
  const tx = { from, to: sendTo, amount: Number(amount), signature: sig_b64, pubkey_spki: from };
  // local pending store
  let pending = load_local('pending_txs') || [];
  pending.push(tx);
  save_local('pending_txs', pending);
  setSendMsg('トランザクションをローカルに保存しました。サーバーへ送信中...');
  if (submitToServer) {
    const resp = await fetch(API_ROOT + '/submit_tx', {
      method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(tx)
    });
    const resj = await resp.json();
    if (resp.ok) {
      setSendMsg('トランザクション送信成功（サーバーに受理されました）');
      // clear local pending entry (we'll clear all to simplify)
      save_local('pending_txs', []);
    } else {
      setSendMsg('サーバー受理失敗: ' + JSON.stringify(resj));
    }
  }
}

// Balance
async function check_balance(pub) {
  const q = new URLSearchParams({ pub });
  const resp = await fetch(API_ROOT + '/balance?' + q.toString());
  const rj = await resp.json();
  if (resp.ok) {
    document.getElementById('balance_display').textContent = '残高: ' + rj.balance;
  } else {
    document.getElementById('balance_display').textContent = 'エラー: ' + JSON.stringify(rj);
  }
}

// Chain fetch & display
async function show_chain() {
  const resp = await fetch(API_ROOT + '/get_chain');
  const j = await resp.json();
  const c = j.chain || [];
  save_local('chain', c);
  render_chain(c);
}
function render_chain(c) {
  const container = document.getElementById('chain_display');
  container.innerHTML = '';
  c.forEach(blk=>{
    const div = document.createElement('div');
    div.className = 'block';
    const ts = new Date(blk.timestamp*1000);
    // Tokyo time display
    const tokyo = new Date(blk.timestamp*1000 + (9*60*60*1000));
    div.innerHTML = `<div><strong>ブロック #${blk.index}</strong> （${tokyo.toLocaleString('ja-JP')}）</div>
      <div>hash: ${blk.hash}</div>
      <div>prev: ${blk.prev_hash}</div>
      <div>nonce: ${blk.nonce}</div>
      <div>miner: ${blk.miner}</div>
      <div>transactions:</div>
      <pre>${JSON.stringify(blk.transactions, null, 2)}</pre>`;
    container.appendChild(div);
  });
}

// Adopt chain: send local chain to server for comparison
async function adopt_chain() {
  const local_chain = load_local('chain') || [];
  const resp = await fetch(API_ROOT + '/submit_chain', {
    method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ chain: local_chain })
  });
  const r = await resp.json();
  if (resp.ok) {
    if (r.status === 'replaced') {
      // server replaced its chain with our longer chain
      logEvent('サーバーがチェーンを置き換えました。');
    } else {
      logEvent('サーバー拒否: ' + JSON.stringify(r));
    }
  } else {
    logEvent('サーバー応答エラー: ' + JSON.stringify(r));
  }
  // Also fetch authoritative chain
  await show_chain();
}

// Clear local chain & pending
function clear_local_chain_and_txs() {
  localStorage.removeItem('chain');
  localStorage.removeItem('pending_txs');
  logEvent('ローカルのチェーンとトランザクションを削除しました');
  document.getElementById('chain_display').innerHTML = '';
}

// Mining
let miningInProgress = false;
async function start_mining() {
  if (miningInProgress) return;
  const keys = load_local('keys');
  if (!keys) { setMineStatus('鍵がありません'); return; }
  miningInProgress = true;
  setMineStatus('マイニング中');
  const miner_pub = keys.pub_spki;
  const resp = await fetch(API_ROOT + '/mine', {
    method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ miner_pub })
  });
  const rj = await resp.json();
  if (resp.ok) {
    setMineStatus('マイニング成功（報酬: ' + rj.reward + '）');
    // update local chain
    save_local('chain', rj.block ? (load_local('chain') || []).concat([rj.block]) : load_local('chain'));
    setTimeout(()=>{ setMineStatus(''); }, 3000);
  } else {
    setMineStatus('マイニング失敗: ' + JSON.stringify(rj));
    setTimeout(()=>{ setMineStatus(''); }, 3000);
  }
  miningInProgress = false;
}

// Utilities for UI messages
function setSendMsg(s) { document.getElementById('send_msg').textContent = s; }
function setMineStatus(s) { document.getElementById('mine_status').textContent = s; }
function logEvent(s) {
  const el = document.getElementById('event_log');
  const p = document.createElement('div');
  p.textContent = `[${new Date().toLocaleTimeString()}] ${s}`;
  el.prepend(p);
}

// SSE listener
function setup_sse() {
  try {
    const es = new EventSource(API_ROOT + '/events');
    es.addEventListener('mined', ev => {
      const d = JSON.parse(ev.data);
      logEvent('新しいブロックがマイニングされました: #' + d.block_index + ' by ' + d.miner);
      // fetch chain and compare
      show_chain();
    });
    es.addEventListener('chain_replaced', ev=>{
      const d = JSON.parse(ev.data);
      logEvent('サーバーチェーンが置換されました（長さ ' + d.chain_length + '）');
      show_chain();
    });
    es.addEventListener('new_tx', ev=>{
      const d = JSON.parse(ev.data);
      logEvent('新しいトランザクションが追加されました');
    });
    es.onerror = (e) => {
      logEvent('SSE接続エラーまたは切断');
      es.close();
      // 再接続は数秒後に試す
      setTimeout(setup_sse, 3000);
    };
  } catch (e) {
    console.error('SSE unavailable', e);
  }
}

// DOM wiring
document.getElementById('gen_keys').addEventListener('click', generate_keys);
document.getElementById('reset_keys').addEventListener('click', reset_keys);
document.getElementById('export_pub').addEventListener('click', ()=>{
  const k = load_local('keys');
  if (k) document.getElementById('pub_display').textContent = k.pub_spki;
  else document.getElementById('pub_display').textContent = '（未生成）';
});

document.getElementById('create_tx').addEventListener('click', async ()=>{
  const to = document.getElementById('tx_to').value.trim();
  const amount = document.getElementById('tx_amount').value;
  if (!to) { setSendMsg('受取先公開鍵を入力してください'); return; }
  await create_and_send_tx(to, amount, true);
});
document.getElementById('local_sign').addEventListener('click', async ()=>{
  const to = document.getElementById('tx_to').value.trim();
  const amount = document.getElementById('tx_amount').value;
  if (!to) { setSendMsg('受取先公開鍵を入力してください'); return; }
  await create_and_send_tx(to, amount, false);
});
document.getElementById('check_balance').addEventListener('click', ()=>{
  const pub = document.getElementById('balance_pub').value.trim();
  if (!pub) { document.getElementById('balance_display').textContent = '公開鍵を入力してください'; return; }
  check_balance(pub);
});
document.getElementById('show_chain').addEventListener('click', show_chain);
document.getElementById('adopt_chain').addEventListener('click', adopt_chain);
document.getElementById('clear_local_chain').addEventListener('click', clear_local_chain_and_txs);
document.getElementById('start_mine').addEventListener('click', start_mining);

// on load
window.addEventListener('load', ()=>{
  // render stored keys if exists
  const keys = load_local('keys');
  if (keys) {
    document.getElementById('pub_display').textContent = keys.pub_spki;
    document.getElementById('priv_display').textContent = JSON.stringify(keys.priv_jwk, null, 2);
  }
  setup_sse();
});
</script>

</body>
</html>
