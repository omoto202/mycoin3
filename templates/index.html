<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>MyCoin Wallet (localStorage)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.6.1/elliptic.min.js"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<style>
body { font-family: Arial, sans-serif; padding: 20px; background: #f7f7f7; }
input { padding: 6px; margin: 6px 0; width: 320px; }
button { padding: 6px 10px; margin: 4px; }
textarea { width: 100%; }
.block { background: #fff; padding: 12px; border-radius: 6px; margin-bottom: 12px; }
#history { white-space: pre-wrap; background:#f9f9f9; padding:8px; border-radius:4px; max-height: 400px; overflow:auto; }
.status { margin-top:8px; color:#333; }
</style>
</head>
<body>
<h1>MyCoin Wallet (localStorage)</h1>

<div class="block">
  <h2>鍵管理</h2>
  <button id="genBtn">鍵ペア生成</button>
  <button id="resetBtn">鍵ペアリセット</button>
  <div id="keys">鍵がありません。</div>
</div>

<div class="block">
  <h2>送金</h2>
  <form id="txForm">
    <input name="recipient" placeholder="受信者の公開鍵" required><br>
    <input name="amount" placeholder="金額" required><br>
    <button type="submit">送信</button>
  </form>
  <div id="txResult" class="status"></div>
</div>

<div class="block">
  <h2>残高確認</h2>
  <form id="balanceForm">
    <input name="address" placeholder="アドレスを入力（空で自分の公開鍵）"><br>
    <button type="submit">残高取得</button>
  </form>
  <div id="balance">残高: -</div>
</div>

<div class="block">
  <h2>ブロックチェーン</h2>
  <button id="loadChainBtn">履歴を表示</button>
  <button id="clearLocalChainBtn">ローカルチェーン削除</button>
  <div id="history"></div>
  <div id="chainStatus" class="status"></div>
</div>

<div class="block">
  <h2>マイニング</h2>
  <button id="mineBtn">マイニング開始</button>
  <div id="mineStatus" class="status"></div>
</div>

<script>
/* --------- 初期セットアップ --------- */
const ec = new elliptic.ec('secp256k1');
const socket = io();

/* LocalStorage のキー */
const LS_CHAIN_KEY = 'mycoin_chain_v1';

/* 既存の鍵管理ヘルパー（変更なし） */
function saveKeys(pub, priv) {
  localStorage.setItem('publicKey', pub);
  localStorage.setItem('privateKey', priv);
}
function loadKeys() {
  return {
    publicKey: localStorage.getItem('publicKey'),
    privateKey: localStorage.getItem('privateKey')
  };
}
function updateKeysUI() {
  const { publicKey, privateKey } = loadKeys();
  const el = document.getElementById('keys');
  if(publicKey && privateKey) {
    el.innerHTML = `<div><b>公開鍵</b><br><textarea rows="2">${publicKey}</textarea></div>
                    <div><b>秘密鍵</b><br><textarea rows="2">${privateKey}</textarea></div>`;
  } else {
    el.innerText = "鍵がありません。生成してください。";
  }
}
document.getElementById('genBtn').onclick = function(){
  const key = ec.genKeyPair();
  const priv = key.getPrivate('hex');
  const pub = key.getPublic('hex');
  saveKeys(pub, priv);
  updateKeysUI();
  updateBalance(); loadAndDisplayChain(); // 表示更新
};
document.getElementById('resetBtn').onclick = function(){
  localStorage.removeItem('publicKey');
  localStorage.removeItem('privateKey');
  updateKeysUI();
  document.getElementById('balance').innerText = "残高: -";
  document.getElementById('history').innerText = "";
};

/* --------- LocalStorage チェーン関係ユーティリティ --------- */

// 保存（chainData は {length, chain} か、chain array 単体でも扱える）
function saveLocalChain(chainData) {
  // store as server-response-style object {length, chain}
  let obj;
  if(Array.isArray(chainData)) {
    obj = { length: chainData.length, chain: chainData };
  } else {
    obj = chainData;
  }
  try {
    localStorage.setItem(LS_CHAIN_KEY, JSON.stringify(obj));
    document.getElementById('chainStatus').innerText = `ローカルチェーンを保存しました（length=${obj.length})`;
  } catch(e) {
    console.error("saveLocalChain error", e);
    document.getElementById('chainStatus').innerText = "ローカル保存に失敗しました";
  }
}

// 取得（存在しなければ null）
function getLocalChainObj() {
  const s = localStorage.getItem(LS_CHAIN_KEY);
  if(!s) return null;
  try {
    return JSON.parse(s);
  } catch(e) {
    return null;
  }
}

/* --------- 表示用ユーティリティ --------- */
function displayChainObj(chainObj) {
  if(!chainObj || !Array.isArray(chainObj.chain)) {
    document.getElementById('history').innerText = "(ローカルチェーンなし)";
    return;
  }
  const arr = chainObj.chain;
  let out = "";
  arr.forEach((block, idx) => {
    out += `Block #${idx}\n`;
    out += `Timestamp: ${new Date(block.timestamp*1000).toLocaleString()}\n`;
    out += `Hash: ${block.hash}\n`;
    out += `Prev: ${block.prev_hash}\n`;
    out += `Transactions:\n`;
    if(!block.transactions || block.transactions.length === 0) {
      out += "  (none)\n";
    } else {
      block.transactions.forEach(tx => {
        out += `  ${tx.sender} -> ${tx.recipient} : ${tx.amount}\n`;
      });
    }
    out += `\n-------------------------\n`;
  });
  document.getElementById('history').innerText = out;
}

/* --------- サーバーからチェーンを取ってきて比較する関数 --------- */
/*
  比較ルール（簡易）：
  - serverObj.length >= localLength なら serverObj を採用して local に保存・表示（サーバーが同じか長い）
  - serverObj.length < localLength なら local を保持（あなたのブラウザが"先行"している）
  - どちらでもない（エラー）はサーバーのチェーンを表示（安全側）
*/
async function fetchServerChainAndCompare(noteContext="manual") {
  document.getElementById('chainStatus').innerText = "サーバーのチェーンを取得しています...";
  try {
    const res = await fetch('/chain');
    if(!res.ok) {
      document.getElementById('chainStatus').innerText = `サーバーからチェーン取得失敗: ${res.status}`;
      return null;
    }
    const serverObj = await res.json(); // {length, chain}
    const localObj = getLocalChainObj();
    const localLen = localObj && Array.isArray(localObj.chain) ? localObj.chain.length : 0;
    const serverLen = serverObj.length || (Array.isArray(serverObj.chain) ? serverObj.chain.length : 0);

    if(serverLen >= localLen) {
      // サーバーが同じ長さか長い → サーバーを採用して保存
      saveLocalChain(serverObj);
      displayChainObj(serverObj);
      document.getElementById('chainStatus').innerText = `サーバーのチェーンを保存・表示しました（server ${serverLen} >= local ${localLen}）`;
    } else {
      // ローカルの方が長い → ローカルを維持（サーバーは短い）
      displayChainObj(localObj);
      document.getElementById('chainStatus').innerText = `ローカルチェーンを維持します（local ${localLen} > server ${serverLen}）`;
    }
    return { serverObj, localObj };
  } catch (e) {
    console.error("fetchServerChainAndCompare error", e);
    document.getElementById('chainStatus').innerText = "チェーン比較中にエラー";
    return null;
  }
}

/* --------- 既存の関数（送金/残高/表示/マイニング）を localStorage ロジックに統合 --------- */

document.getElementById('txForm').onsubmit = async function(e){
  e.preventDefault();
  const { publicKey } = loadKeys();
  if(!publicKey) { alert("鍵を生成してください"); return; }

  const recipient = e.target.recipient.value.trim();
  const amount = e.target.amount.value.trim();
  if(!recipient || !amount) { alert("正しい入力をしてください"); return; }

  const payload = { sender: publicKey, recipient, amount };
  const res = await fetch('/transactions/new', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  });
  const text = await res.text();
  document.getElementById('txResult').innerText = text;

  // トランザクションを送ったら、サーバーのチェーンと比較して local を更新する（非同期）
  setTimeout(()=>{ fetchServerChainAndCompare("after_tx"); }, 2000);
};

document.getElementById('balanceForm').onsubmit = async function(e){
  e.preventDefault();
  let address = e.target.address.value.trim();
  if(!address) address = loadKeys().publicKey;
  await updateBalance(address);
};

async function updateBalance(address){
  const addr = address || loadKeys().publicKey;
  if(!addr) { document.getElementById('balance').innerText = "残高: -"; return; }
  try {
    const res = await fetch('/balance/' + addr);
    if(!res.ok) {
      document.getElementById('balance').innerText = "残高取得エラー";
      return;
    }
    const j = await res.json();
    document.getElementById('balance').innerText = `残高: ${j.balance}`;
  } catch(e) {
    document.getElementById('balance').innerText = "残高取得エラー";
  }
}

/* "履歴を表示" ボタンはサーバーから取得して比較処理を呼ぶ */
document.getElementById('loadChainBtn').onclick = loadAndDisplayChain;
async function loadAndDisplayChain(){
  document.getElementById('chainStatus').innerText = "ローカルとサーバーを比較しています...";
  await fetchServerChainAndCompare("manual_load");
}

/* マイニング処理：サーバーでマイニングを行い、結果を受け取ってからチェーン比較 */
let mining=false;
document.getElementById('mineBtn').onclick = async function(){
  if(mining) return;
  const { publicKey } = loadKeys();
  if(!publicKey) { alert("鍵を生成してください"); return; }

  mining = true;
  const statusEl = document.getElementById('mineStatus');
  statusEl.innerText = "マイニング中...";

  try {
    const res = await fetch('/mine', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({miner: publicKey})
    });
    if(!res.ok){
      statusEl.innerText = "Error: " + await res.text();
      // マイニング失敗時でもサーバーチェーンを取りにいく
      await fetchServerChainAndCompare("mine_error");
    } else {
      const j = await res.json();
      statusEl.innerText = `Block mined: ${j.block_hash} (miner: ${j.miner})`;

      // マイニング後：サーバーの最新チェーンを取得して比較し、サーバーが長ければ保存。ローカルが長ければローカルを維持。
      await fetchServerChainAndCompare("after_mine");

      // 残高と表示更新
      await updateBalance(j.miner);
    }
  } catch(err){
    statusEl.innerText = "Error: " + err;
  } finally {
    mining=false;
    setTimeout(()=>{ document.getElementById('mineStatus').innerText = ""; }, 3000);
  }
};

document.getElementById('clearLocalChainBtn').onclick = () => {
    localStorage.removeItem('blockchain');
    alert("ローカルのブロックチェーンデータを削除しました");
};

/* Socket.IO: サーバーから update を受け取ったらサーバーのチェーンを取得して比較して保存判断 */
socket.on('update', async (data) => {
  // data.type: 'transaction' or 'block'
  // ここではサーバーのチェーンを取得して local と比較する
  document.getElementById('chainStatus').innerText = "サーバー通知受信、チェーンを取得中...";
  await fetchServerChainAndCompare("socket_update");
  // 可能であれば残高も更新
  const pub = loadKeys().publicKey;
  if(pub) await updateBalance(pub);
});

/* ページロード時の挙動：
   1) localStorage にチェーンがあれば表示
   2) すぐサーバーから /chain を取り、長さを比較して上書き or 保持する
*/
async function loadAndDisplayChainOnStart() {
  const localObj = getLocalChainObj();
  if(localObj) {
    displayChainObj(localObj);
    document.getElementById('chainStatus').innerText = `ローカルチェーンを読み込みました（length=${localObj.length})`;
  } else {
    document.getElementById('chainStatus').innerText = "ローカルチェーンはありません。サーバーから取得します。";
  }
  // 直ちにサーバーと比較してローカルを上書きするか決める
  await fetchServerChainAndCompare("startup");
}

/* 初期化 */
updateKeysUI();
updateBalance();
loadAndDisplayChainOnStart();

/* フォールバックで定期的にチェーンを確認（15秒毎） */
setInterval(()=>{ fetchServerChainAndCompare("polling"); }, 15000);
</script>
</body>
</html>