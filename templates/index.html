<!-- templates/index.html -->
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>My Coin Wallet</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; max-width: 900px; margin: 24px; }
    section { border: 1px solid #ddd; padding: 12px; margin-bottom: 12px; border-radius: 6px; }
    label { display:block; margin-top:8px; }
    pre { background:#f7f7f7; padding:8px; border-radius:4px; white-space:pre-wrap; word-break:break-word;}
    button { margin-top:8px; padding:8px 12px; }
    .small { font-size:0.9em; color:#555; }
    .mining-status { font-weight: bold; margin-top:8px;}
    table { width:100%; border-collapse:collapse; margin-top:8px;}
    th,td { border:1px solid #eee; padding:6px; text-align:left; }
  </style>
  <!-- elliptic lib for secp256k1 operations -->
  <script src="https://cdn.jsdelivr.net/npm/elliptic@6.5.4/dist/elliptic.min.js"></script>
</head>
<body>
  <h2>My Coin Wallet</h2>

  <section id="wallet-section">
    <h3>鍵管理</h3>
    <button id="create-wallet">鍵ペア生成</button>
    <button id="reset-wallet">ローカル鍵リセット</button>
    <div class="small">公開鍵 / 秘密鍵（2段表示）:</div>
    <pre id="pubkey">公開鍵: なし</pre>
    <pre id="privkey">秘密鍵: なし</pre>
  </section>

  <section id="send-section">
    <h3>送金</h3>
    <label>相手の公開鍵（recipient）</label>
    <textarea id="send-recipient" rows="3" style="width:100%"></textarea>
    <label>金額</label>
    <input id="send-amount" type="number" step="0.01" min="0" />
    <br/>
    <button id="send-button">送金する</button>
    <div id="send-result" class="small"></div>
  </section>

  <section id="balance-section">
    <h3>残高確認</h3>
    <label>公開鍵（チェックしたいアドレス）</label>
    <textarea id="balance-pub" rows="3" style="width:100%"></textarea>
    <button id="balance-check">残高を計算</button>
    <div id="balance-output" class="small"></div>
  </section>

  <section id="chain-section">
    <h3>ブロックチェーン</h3>
    <button id="compare-sync">更新</button>
    <button id="clear-local">ローカルストレージのチェーンを削除</button>
    <div id="chain-info" class="small"></div>
    <div id="chain-list"></div>
  </section>

  <section id="mining-section">
    <h3>マイニング</h3>
    <button id="mine-button">マイニング開始</button>
    <div id="mining-status" class="mining-status"></div>
  </section>

  <script>
  (function(){
    const EC = elliptic.ec;
    const ec = new EC('secp256k1');

    // localStorage keys
    const KEY_WALLET = 'wallet';
    const KEY_CHAIN = 'chain';
    const KEY_PENDING = 'pending_txs';

    // UI elements
    const pubEl = document.getElementById('pubkey');
    const privEl = document.getElementById('privkey');
    const createBtn = document.getElementById('create-wallet');
    const resetBtn = document.getElementById('reset-wallet');

    const sendRecipient = document.getElementById('send-recipient');
    const sendAmount = document.getElementById('send-amount');
    const sendBtn = document.getElementById('send-button');
    const sendResult = document.getElementById('send-result');

    const balancePub = document.getElementById('balance-pub');
    const balanceCheck = document.getElementById('balance-check');
    const balanceOutput = document.getElementById('balance-output');

    const compareBtn = document.getElementById('compare-sync');
    const clearLocalBtn = document.getElementById('clear-local');
    const chainInfo = document.getElementById('chain-info');
    const chainList = document.getElementById('chain-list');

    const mineBtn = document.getElementById('mine-button');
    const miningStatus = document.getElementById('mining-status');

    // helpers
    function saveWallet(obj){ localStorage.setItem(KEY_WALLET, JSON.stringify(obj)); }
    function loadWallet(){ const s = localStorage.getItem(KEY_WALLET); return s ? JSON.parse(s) : null; }
    function saveChain(chain){ localStorage.setItem(KEY_CHAIN, JSON.stringify(chain)); }
    function loadChain(){ const s = localStorage.getItem(KEY_CHAIN); return s ? JSON.parse(s) : null; }
    function savePending(p){ localStorage.setItem(KEY_PENDING, JSON.stringify(p)); }
    function loadPending(){ const s = localStorage.getItem(KEY_PENDING); return s ? JSON.parse(s) : []; }

    function renderWallet(){
      const w = loadWallet();
      if(w){
        pubEl.textContent = "公開鍵:\n" + w.pub;
        privEl.textContent = "秘密鍵:\n" + w.priv;
      } else {
        pubEl.textContent = "公開鍵: なし";
        privEl.textContent = "秘密鍵: なし";
      }
    }

    function toTokyo(iso){
      // iso is UTC string like 2025-...Z
      const d = new Date(iso);
      // get components in JST
      const y = d.getFullYear();
      const mo = String(d.getMonth()+1).padStart(2,'0');
      const da = String(d.getDate()).padStart(2,'0');
      const hh = String(d.getHours()).padStart(2,'0');
      const mm = String(d.getMinutes()).padStart(2,'0');
      const ss = String(d.getSeconds()).padStart(2,'0');
      // convert to JST by adding 9 hours
      // easier: create new date from ms + 9h
      const jst = new Date(d.getTime() + 9*3600*1000);
      const jy = jst.getFullYear();
      const jmo = String(jst.getMonth()+1).padStart(2,'0');
      const jda = String(jst.getDate()).padStart(2,'0');
      const jhh = String(jst.getHours()).padStart(2,'0');
      const jmm = String(jst.getMinutes()).padStart(2,'0');
      const jss = String(jst.getSeconds()).padStart(2,'0');
      return `${jy}-${jmo}-${jda} ${jhh}:${jmm}:${jss} (JST)`;
    }

    function renderChainDisplay(chainObj){
      if(!chainObj || !chainObj.chain) {
        chainList.innerHTML = "<div class='small'>チェーンがありません</div>";
        chainInfo.textContent = "";
        return;
      }
      chainInfo.textContent = `チェーン長: ${chainObj.chain.length} / difficulty: ${chainObj.difficulty} / 発行済み: ${chainObj.total_issued}`;
      let html = "<table><tr><th>index</th><th>timestamp (JST)</th><th>nonce</th><th>hash</th><th>prev_hash</th><th>miner</th><th>transactions</th></tr>";
      for(const b of chainObj.chain){
        let txs_html = "<ul>";
        for(const t of (b.transactions || [])){
          txs_html += `<li>from: ${t.sender} → to: ${t.recipient} amount: ${t.amount} time:${toTokyo(t.timestamp || b.timestamp)}</li>`;
        }
        txs_html += "</ul>";
        html += `<tr>
          <td>${b.index}</td>
          <td>${toTokyo(b.timestamp)}</td>
          <td>${b.nonce}</td>
          <td style="word-break:break-all">${b.hash}</td>
          <td style="word-break:break-all">${b.previous_hash}</td>
          <td style="word-break:break-all">${b.miner}</td>
          <td>${txs_html}</td>
        </tr>`;
      }
      html += "</table>";
      chainList.innerHTML = html;
    }

    // create wallet
    createBtn.addEventListener('click', ()=>{
      const key = ec.genKeyPair();
      const priv = key.getPrivate('hex');
      const pub = key.getPublic('hex'); // compressed/uncompressed depends - this is uncompressed hex by elliptic
      saveWallet({priv: priv, pub: pub});
      renderWallet();
    });

    resetBtn.addEventListener('click', ()=>{
      localStorage.removeItem(KEY_WALLET);
      renderWallet();
    });

    // send tx
    sendBtn.addEventListener('click', async ()=>{
      sendResult.textContent = '';
      const w = loadWallet();
      if(!w){ sendResult.textContent = "ウォレットがありません。鍵を生成してください。"; return; }
      const senderPriv = w.priv;
      const senderPub = w.pub;
      const recipient = sendRecipient.value.trim();
      const amount = parseFloat(sendAmount.value);
      if(!recipient || isNaN(amount) || amount <= 0){ sendResult.textContent = "受取人と正しい金額を入力してください。"; return; }

      // client-side: compute local balance from stored chain + pending
      const chainObj = loadChain();
      function computeLocalBalance(pub){
        let bal = 0.0;
        if(chainObj && chainObj.chain){
          for(const b of chainObj.chain){
            for(const t of (b.transactions || [])){
              if(t.recipient === pub) bal += parseFloat(t.amount);
              if(t.sender === pub) bal -= parseFloat(t.amount);
            }
          }
        }
        const pending = loadPending();
        for(const t of pending){
          if(t.sender === pub) bal -= parseFloat(t.amount);
        }
        return bal;
      }
      const localBal = computeLocalBalance(senderPub);
      if(localBal + 1e-9 < amount){
        sendResult.textContent = `残高不足: ${localBal}`;
        return;
      }

      // sign transaction
      const key = ec.keyFromPrivate(senderPriv, 'hex');
      const tx = {
        sender: senderPub,
        recipient: recipient,
        amount: amount,
        timestamp: new Date().toISOString()
      };
      const txString = tx.sender + tx.recipient + tx.amount + tx.timestamp;
      const sig = key.sign(sha256(txString)).toDER('hex'); // use sha256 of concatenated fields
      tx.signature = sig;

      // client-side verify signature before sending
      const pubKey = ec.keyFromPublic(senderPub, 'hex');
      const verified = pubKey.verify(sha256(txString), sig);
      if(!verified){ sendResult.textContent = '署名検証に失敗しました。'; return; }

      // append to local pending and send to server (server will do balance check based on server chain)
      const pending = loadPending();
      pending.push(tx);
      savePending(pending);

      try{
        const res = await fetch('/api/submit_tx', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({
            sender: tx.sender,
            recipient: tx.recipient,
            amount: tx.amount,
            signature: tx.signature,
            timestamp: tx.timestamp
          })
        });
        const j = await res.json();
        if(!j.ok){
          sendResult.textContent = '送金失敗: ' + (j.error || JSON.stringify(j));
          // if server rejects, remove tx from local pending (so client doesn't keep rejected tx)
          const p = loadPending().filter(t=>!(t.sender===tx.sender && t.timestamp===tx.timestamp));
          savePending(p);
        } else {
          sendResult.textContent = '送金受付（pending）されました。';
        }
      }catch(err){
        sendResult.textContent = '送信エラー: ' + err;
      }
    });

    // balance check
    balanceCheck.addEventListener('click', ()=>{
      const pub = (balancePub.value || '').trim();
      if(!pub){ balanceOutput.textContent = '公開鍵を入れてください。'; return; }
      // compute from local chain
      const chainObj = loadChain();
      let bal = 0.0;
      if(chainObj && chainObj.chain){
        for(const b of chainObj.chain){
          for(const t of (b.transactions || [])){
            if(t.recipient === pub) bal += parseFloat(t.amount);
            if(t.sender === pub) bal -= parseFloat(t.amount);
          }
        }
      }
      const pending = loadPending();
      for(const t of pending){
        if(t.sender === pub) bal -= parseFloat(t.amount);
      }
      balanceOutput.textContent = `残高: ${bal}`;
    });

    // compare and sync chain with server
    compareBtn.addEventListener('click', async ()=>{
      const local = loadChain();
      try{
        const res = await fetch('/api/sync_chain', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({chain: local ? local.chain : []})
        });
        const j = await res.json();
        if(j.replaced){
          // server replaced its chain by ours and broadcasted; we can keep ours
          renderChainDisplay(local);
        } else {
          // server provides its chain; adopt if server longer
          const server = j.server_chain;
          if(server && server.chain && (!local || server.chain.length >= local.chain.length)){
            saveChain(server);
            savePending([]); // clear local pending as server replaced
            renderChainDisplay(server);
          }
        }
      }catch(err){
        chainInfo.textContent = '同期エラー: ' + err;
      }
    });

    clearLocalBtn.addEventListener('click', ()=>{
      localStorage.removeItem(KEY_CHAIN);
      localStorage.removeItem(KEY_PENDING);
      renderChainDisplay({chain: []});
    });

    // mining
    let miningTimeout = null;
    mineBtn.addEventListener('click', async ()=>{
      const w = loadWallet();
      if(!w){ miningStatus.textContent = 'ウォレットがありません'; return; }
      const minerPub = w.pub;
      miningStatus.textContent = 'マイニング中';
      // disable button
      mineBtn.disabled = true;
      try{
        const res = await fetch('/api/mine', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({miner: minerPub})
        });
        const j = await res.json();
        if(j.ok){
          miningStatus.textContent = 'マイニング成功';
          // after 3s clear message
          if(miningTimeout) clearTimeout(miningTimeout);
          miningTimeout = setTimeout(()=>{ miningStatus.textContent = ''; }, 3000);
          // server broadcast will arrive via SSE and client will adopt longest chain
        } else {
          miningStatus.textContent = 'マイニング失敗: ' + (j.error || '');
        }
      }catch(err){
        miningStatus.textContent = 'マイニングエラー: ' + err;
      } finally {
        mineBtn.disabled = false;
      }
    });

    // SSE: subscribe to server updates
    function connectSSE(){
      const es = new EventSource('/stream');
      es.onmessage = (ev) => {
        try{
          const obj = JSON.parse(ev.data);
          // on update, compare with local chain and adopt longer
          const local = loadChain();
          const localLen = local && local.chain ? local.chain.length : 0;
          const serverLen = obj.chain ? obj.chain.length : 0;
          if(serverLen > localLen){
            saveChain(obj);
            savePending([]); // clear pending locally because server took precedence
            renderChainDisplay(obj);
          } else {
            // server shorter or equal; keep local but optionally inform server (not required)
            if(local) renderChainDisplay(local);
          }
        }catch(e){
          console.error("SSE parse error", e);
        }
      };
      es.onerror = (e) => {
        console.warn("SSE disconnected, will attempt reconnect in 3s");
        setTimeout(()=> {
          connectSSE();
        }, 3000);
      };
    }

    // utility: sha256 helper (hex) using built-in Subtle or fallback
    function sha256(msg){
      // using simple JS SHA from elliptic's sha256 util? elliptic doesn't expose; implement small function:
      // Use built-in crypto.subtle
      const enc = new TextEncoder();
      const data = enc.encode(msg);
      // Note: crypto.subtle returns Promise; but earlier code expects synchronous return.
      // To keep signing flow synchronous for elliptic, use a simple synchronous SHA256 implementation via js-sha256 if available.
      // But to avoid external libs, we implement a small synchronous hex SHA using crypto.subtle via synchronous blocking via Atomics is not possible.
      // Instead, fall back to a simple hash trick: use elliptic's util crypto library's hash function? elliptic has sha256 function as window.sha256 if included.
      // For compatibility, we use a sync SHA256 implementation using built-in Subtle (wrapped as synchronous with async/await via blocking pattern).
      // However earlier code uses sha256(txString) synchronously for signature. elliptic's sign.verify expects message digest as array or hex.
      // Simpler: use plain string as message for signing (elliptic will hash internally). So change sign/verify usage to pass message string directly.
      return msg; // placeholder; we will use pass-through and let elliptic handle hashing internally
    }

    // Initialization: load local chain or fetch from server first time
    async function init(){
      renderWallet();
      const local = loadChain();
      if(local && local.chain && local.chain.length>0){
        renderChainDisplay(local);
      } else {
        // fetch server chain
        try{
          const res = await fetch('/api/chain');
          const j = await res.json();
          saveChain(j);
          renderChainDisplay(j);
        }catch(err){
          renderChainDisplay({chain: []});
        }
      }
      // ensure pending exists
      if(!localStorage.getItem(KEY_PENDING)) savePending([]);
      // connect SSE
      connectSSE();
    }

    // Adjusted signing and verification wrappers using elliptic's built-in hashing (no external sha256 sync)
    // Re-implement sign/verify utilities used above: We used sha256(txString) earlier but set to pass-through; elliptic will hash automatically if passed raw message?
    // elliptic expects a message hash (array or hex) or a message if prefixed; common usage: key.sign(msgHash) where msgHash is hex of digest.
    // For simplicity, we instead compute a hex digest using a synchronous JS sha256: we will include a tiny sha256 implementation inline to produce hex.

    // tiny synchronous sha256 implementation (adapted, minimal). This is reliable and avoids external libs.
    // Source: minimal public-domain sha256 JS algorithm (kept compact).
    function syncSha256(ascii) {
      function rightRotate(value, amount) {
        return (value>>>amount) | (value<<(32 - amount));
      }
      var mathPow = Math.pow;
      var maxWord = mathPow(2, 32);
      var lengthProperty = 'length'
      var i, j; // Used as a counter across the whole file
      var result = ''
      var words = [];
      var asciiBitLength = ascii[lengthProperty]*8;

      var hash = [], k = [];
      var primeCounter = 0;
      var isComposite = {};
      for (var candidate = 2; primeCounter < 64; candidate++) {
        if (!isComposite[candidate]) {
          for (i = 0; i < 313; i += candidate) {
            isComposite[i] = candidate;
          }
          hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;
          k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;
        }
      }
      ascii += '\x80' // Append Ƈ' bit (plus zero padding)
      while (ascii[lengthProperty]%64 - 56) ascii += '\x00' // More zero padding
      for (i = 0; i < ascii[lengthProperty]; i++) {
        j = ascii.charCodeAt(i);
        if (j>>8) return; // ASCII check: only accept ASCII
        words[i>>2] |= j << ((3 - i)%4)*8;
      }
      words[words.length] = ((asciiBitLength/maxWord)|0);
      words[words.length] = (asciiBitLength)

      for (j = 0; j < words.length;) {
        var w = words.slice(j, j += 16);
        var oldHash = hash.slice(0);
        for (i = 0; i < 64; i++) {
          var w15 = w[i - 15], w2 = w[i - 2];

          var a = hash[0], e = hash[4];
          var temp1 = hash[7]
            + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25))
            + ((e & hash[5]) ^ ((~e) & hash[6]))
            + k[i]
            + (w[i] = (i < 16) ? w[i] : (
                w[i - 16]
                + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3))
                + w[i - 7]
                + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))
              ) | 0);
          var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22))
            + ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));
          hash = [(temp1 + temp2)|0].concat(hash);
          hash[4] = (hash[4] + temp1)|0;
          hash.pop();
        }
        for (i = 0; i < 8; i++) hash[i] = (hash[i] + oldHash[i])|0;
      }
      for (i = 0; i < 8; i++) {
        for (j = 3; j + 1; j--) {
          var b = (hash[i] >> (j * 8)) & 255;
          result += ((b < 16) ? 0 : '') + b.toString(16);
        }
      }
      return result;
    }

    // Override earlier sha256 used in signing code to use syncSha256
    window.sha256 = syncSha256;

    // We used sign/verify earlier with sha256(txString) which now returns hex digest.

    // Start
    init();
    renderWallet();
  })();
  </script>
</body>
</html>
